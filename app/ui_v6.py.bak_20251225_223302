import sys, math, random
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional, Set

from PySide6 import QtCore, QtGui, QtWidgets
from app.ui_tweaks import apply_ui_tweaks
from app.dev_hand_overlay import attach_dev_hand_overlay
from app.dev_ui import attach_dev_dialog
from app.trade_ui import attach_trade_button
from app.dev_ui import attach_dev_dialog

# -------------------- Geometry (pointy-top, Colonist-like) --------------------
SQRT3 = 1.7320508075688772

def axial_to_pixel(q: int, r: int, size: float) -> QtCore.QPointF:
    # pointy-top axial
    x = size * SQRT3 * (q + r / 2.0)
    y = size * 1.5 * r
    return QtCore.QPointF(x, y)

def hex_corners(center: QtCore.QPointF, size: float) -> List[QtCore.QPointF]:
    # pointy-top corners (30Р В Р’В Р вЂ™Р’В Р В РІР‚в„ўР вЂ™Р’В Р В Р’В Р В РІР‚В Р В Р’В Р Р†Р вЂљРЎв„ўР В Р вЂ Р Р†Р вЂљРЎвЂєР РЋРЎвЂєР В Р’В Р вЂ™Р’В Р В Р вЂ Р В РІР‚С™Р Р†РІР‚С›РЎС›Р В Р’В Р Р†Р вЂљРІвЂћСћР В РІР‚в„ўР вЂ™Р’В°, 90Р В Р’В Р вЂ™Р’В Р В РІР‚в„ўР вЂ™Р’В Р В Р’В Р В РІР‚В Р В Р’В Р Р†Р вЂљРЎв„ўР В Р вЂ Р Р†Р вЂљРЎвЂєР РЋРЎвЂєР В Р’В Р вЂ™Р’В Р В Р вЂ Р В РІР‚С™Р Р†РІР‚С›РЎС›Р В Р’В Р Р†Р вЂљРІвЂћСћР В РІР‚в„ўР вЂ™Р’В°, ...)
    pts = []
    for i in range(6):
        ang = math.radians(30 + 60 * i)
        pts.append(QtCore.QPointF(
            center.x() + size * math.cos(ang),
            center.y() + size * math.sin(ang),
        ))
    return pts

def quant_key(p: QtCore.QPointF, step: float = 0.5) -> Tuple[int, int]:
    # merge vertices across hexes reliably
    return (int(round(p.x() / step)), int(round(p.y() / step)))

# Base board axial coords: rows 3-4-5-4-3
BASE_AXIAL: List[Tuple[int,int]] = (
    [(0,-2),(1,-2),(2,-2)] +
    [(-1,-1),(0,-1),(1,-1),(2,-1)] +
    [(-2,0),(-1,0),(0,0),(1,0),(2,0)] +
    [(-2,1),(-1,1),(0,1),(1,1)] +
    [(-2,2),(-1,2),(0,2)]
)

RESOURCES = ["wood","brick","sheep","wheat","ore"]
TERRAIN_TO_RES = {
    "forest": "wood",
    "hills": "brick",
    "pasture": "sheep",
    "fields": "wheat",
    "mountains": "ore",
    "desert": None,
}
TERRAIN_COLOR = {
    "forest":   "#22c55e",
    "hills":    "#f97316",
    "pasture":  "#4ade80",
    "fields":   "#facc15",
    "mountains":"#94a3b8",
    "desert":   "#d6c8a0",
}

# pips like Colonist (2/12=1 ... 6/8=5)
PIPS = {2:1,3:2,4:3,5:4,6:5,8:5,9:4,10:3,11:2,12:1}

def make_resource_icon(name: str, size: int = 36) -> QtGui.QPixmap:
    pm = QtGui.QPixmap(size, size)
    pm.fill(QtCore.Qt.transparent)
    p = QtGui.QPainter(pm)
    p.setRenderHint(QtGui.QPainter.Antialiasing, True)

    bg = {
        "wood":"#16a34a",
        "brick":"#f97316",
        "sheep":"#22c55e",
        "wheat":"#facc15",
        "ore":"#94a3b8",
        "any":"#0ea5e9",
    }.get(name, "#64748b")

    # rounded rect
    path = QtGui.QPainterPath()
    path.addRoundedRect(QtCore.QRectF(2,2,size-4,size-4), 10, 10)
    p.fillPath(path, QtGui.QColor(bg))

    # simple white glyph (not copyrighted)
    p.setPen(QtCore.Qt.NoPen)
    p.setBrush(QtGui.QColor("#0b1220"))

    if name == "wood":
        # tree
        p.drawEllipse(QtCore.QRectF(size*0.30, size*0.20, size*0.40, size*0.40))
        p.drawRect(QtCore.QRectF(size*0.47, size*0.55, size*0.06, size*0.25))
    elif name == "brick":
        # bricks
        p.drawRect(QtCore.QRectF(size*0.20, size*0.28, size*0.60, size*0.18))
        p.drawRect(QtCore.QRectF(size*0.20, size*0.52, size*0.60, size*0.18))
    elif name == "sheep":
        # sheep blob
        p.drawEllipse(QtCore.QRectF(size*0.22, size*0.32, size*0.56, size*0.40))
        p.drawEllipse(QtCore.QRectF(size*0.18, size*0.44, size*0.18, size*0.18))
    elif name == "wheat":
        # wheat stalk
        pen = QtGui.QPen(QtGui.QColor("#0b1220"), 3)
        pen.setCapStyle(QtCore.Qt.RoundCap)
        p.setPen(pen)
        p.drawLine(int(size*0.50), int(size*0.22), int(size*0.50), int(size*0.80))
        p.setPen(QtCore.Qt.NoPen)
        p.setBrush(QtGui.QColor("#0b1220"))
        for k in range(5):
            y = size*(0.30 + k*0.10)
            p.drawEllipse(QtCore.QRectF(size*0.52, y, size*0.12, size*0.07))
            p.drawEllipse(QtCore.QRectF(size*0.36, y, size*0.12, size*0.07))
    elif name == "ore":
        # rock
        poly = QtGui.QPolygonF([
            QtCore.QPointF(size*0.28, size*0.65),
            QtCore.QPointF(size*0.40, size*0.28),
            QtCore.QPointF(size*0.62, size*0.25),
            QtCore.QPointF(size*0.76, size*0.55),
            QtCore.QPointF(size*0.56, size*0.78),
        ])
        p.drawPolygon(poly)
    else:
        p.drawEllipse(QtCore.QRectF(size*0.28, size*0.28, size*0.44, size*0.44))

    p.end()
    return pm

def dice_face(n: int, size: int = 42) -> QtGui.QPixmap:
    pm = QtGui.QPixmap(size, size)
    pm.fill(QtCore.Qt.transparent)
    p = QtGui.QPainter(pm)
    p.setRenderHint(QtGui.QPainter.Antialiasing, True)
    # card
    rect = QtCore.QRectF(1,1,size-2,size-2)
    path = QtGui.QPainterPath()
    path.addRoundedRect(rect, 10, 10)
    p.fillPath(path, QtGui.QColor("#f8fafc"))
    p.setPen(QtGui.QPen(QtGui.QColor("#0b1220"), 2))
    p.drawPath(path)
    # pips
    p.setPen(QtCore.Qt.NoPen)
    p.setBrush(QtGui.QColor("#0b1220"))
    def dot(x,y):
        r = size*0.07
        p.drawEllipse(QtCore.QRectF(x-r, y-r, 2*r, 2*r))
    cx, cy = size/2, size/2
    off = size*0.18
    pos = {
        1:[(cx,cy)],
        2:[(cx-off,cy-off),(cx+off,cy+off)],
        3:[(cx-off,cy-off),(cx,cy),(cx+off,cy+off)],
        4:[(cx-off,cy-off),(cx+off,cy-off),(cx-off,cy+off),(cx+off,cy+off)],
        5:[(cx-off,cy-off),(cx+off,cy-off),(cx,cy),(cx-off,cy+off),(cx+off,cy+off)],
        6:[(cx-off,cy-off),(cx+off,cy-off),(cx-off,cy),(cx+off,cy),(cx-off,cy+off),(cx+off,cy+off)],
    }[n]
    for x,y in pos: dot(x,y)
    p.end()
    return pm

# -------------------- Game (minimal, enough for UI correctness) --------------------
@dataclass
class HexTile:
    q: int
    r: int
    terrain: str
    number: Optional[int]
    center: QtCore.QPointF

@dataclass
class Player:
    name: str
    color: QtGui.QColor
    res: Dict[str,int] = field(default_factory=lambda: {k:0 for k in RESOURCES})
    vp: int = 0

@dataclass
class Game:
    seed: int
    size: float = 58.0  # map scale
    tiles: List[HexTile] = field(default_factory=list)
    # geometry:
    vertices: Dict[int, QtCore.QPointF] = field(default_factory=dict)          # vid -> point
    vertex_adj_hexes: Dict[int, List[int]] = field(default_factory=dict)       # vid -> tile indices
    edges: Set[Tuple[int,int]] = field(default_factory=set)                    # (a,b)
    edge_adj_hexes: Dict[Tuple[int,int], List[int]] = field(default_factory=dict)

    # state:
    players: List[Player] = field(default_factory=list)
    bank: Dict[str,int] = field(default_factory=lambda: {k:19 for k in RESOURCES})
    occupied_v: Dict[int, Tuple[int,int]] = field(default_factory=dict)        # vid -> (pid, level 1/2)
    occupied_e: Dict[Tuple[int,int], int] = field(default_factory=dict)        # (a,b)-> pid

    turn: int = 0
    phase: str = "setup"  # setup/main
    rolled: bool = False

    setup_order: List[int] = field(default_factory=lambda: [0,1,1,0])
    setup_idx: int = 0
    setup_need: str = "settlement"  # settlement/road
    setup_anchor_vid: Optional[int] = None
    last_roll: Optional[int] = None

    ports: List[Tuple[Tuple[int,int], str]] = field(default_factory=list)      # (edge, "3:1"/"2:1:wood"...)

def build_board(seed: int, size: float) -> Game:
    rng = random.Random(seed)
    g = Game(seed=seed, size=size)

    terrains = (
        ["forest"]*4 + ["hills"]*3 + ["pasture"]*4 + ["fields"]*4 + ["mountains"]*3 + ["desert"]*1
    )
    rng.shuffle(terrains)

    numbers = [2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12]
    rng.shuffle(numbers)

    tiles: List[HexTile] = []
    ni = 0
    for (q,r), terr in zip(BASE_AXIAL, terrains):
        c = axial_to_pixel(q,r,size)
        num = None
        if terr != "desert":
            num = numbers[ni]; ni += 1
        tiles.append(HexTile(q=q,r=r,terrain=terr,number=num,center=c))
    g.tiles = tiles

    # geometry build (global vertex merge)
    v_map: Dict[Tuple[int,int], int] = {}
    v_points: List[QtCore.QPointF] = []
    v_hexes: Dict[int, List[int]] = {}
    edges: Set[Tuple[int,int]] = set()
    edge_hexes: Dict[Tuple[int,int], List[int]] = {}

    for ti, t in enumerate(tiles):
        corners = hex_corners(t.center, size)
        vids = []
        for p in corners:
            k = quant_key(p, 0.5)
            if k not in v_map:
                vid = len(v_points)
                v_map[k] = vid
                v_points.append(p)
                v_hexes[vid] = []
            vid = v_map[k]
            vids.append(vid)
            v_hexes[vid].append(ti)

        # edges (vid pairs)
        for i in range(6):
            a = vids[i]
            b = vids[(i+1) % 6]
            e = (a,b) if a < b else (b,a)
            edges.add(e)
            edge_hexes.setdefault(e, []).append(ti)

    g.vertices = {i:p for i,p in enumerate(v_points)}
    g.vertex_adj_hexes = v_hexes
    g.edges = edges
    g.edge_adj_hexes = edge_hexes

    # ports: choose 9 coast edges (edges with 1 adjacent hex) evenly by angle
    coast = [e for e,hx in edge_hexes.items() if len(hx)==1]
    center = QtCore.QPointF(0,0)
    def angle_of_edge(e):
        a,b = e
        p = (g.vertices[a] + g.vertices[b]) * 0.5
        return math.atan2(p.y()-center.y(), p.x()-center.x())
    coast.sort(key=angle_of_edge)

    if len(coast) >= 9:
        pick_idx = [int(i * len(coast)/9) for i in range(9)]
        coast9 = [coast[i % len(coast)] for i in pick_idx]
    else:
        coast9 = coast

    port_types = ["3:1"]*4 + [f"2:1:{r}" for r in RESOURCES]
    rng.shuffle(port_types)
    port_types = port_types[:len(coast9)]
    g.ports = list(zip(coast9, port_types))

    # players
    g.players = [
        Player("You", QtGui.QColor("#ef4444")),
        Player("Bot", QtGui.QColor("#e5e7eb")),
    ]
    return g

def edge_neighbors_of_vertex(edges: Set[Tuple[int,int]], vid: int) -> Set[int]:
    out = set()
    for a,b in edges:
        if a == vid: out.add(b)
        elif b == vid: out.add(a)
    return out

def can_place_settlement(g: Game, pid: int, vid: int, require_road: bool) -> bool:
    if vid in g.occupied_v:
        return False
    # distance rule: no adjacent vertex occupied
    for nb in edge_neighbors_of_vertex(g.edges, vid):
        if nb in g.occupied_v:
            return False
    if not require_road:
        return True
    # must connect to own road
    for e in g.edges:
        if vid in e and g.occupied_e.get(e) == pid:
            return True
    return False

def can_place_road(g: Game, pid: int, e: Tuple[int,int], must_touch_vid: Optional[int]=None) -> bool:
    if e in g.occupied_e:
        return False
    a,b = e
    if must_touch_vid is not None and (a != must_touch_vid and b != must_touch_vid):
        return False
    # must connect to own settlement/city or road
    for v in (a,b):
        occ = g.occupied_v.get(v)
        if occ and occ[0] == pid:
            return True
    # connect to own road
    for ee, owner in g.occupied_e.items():
        if owner == pid and (a in ee or b in ee):
            return True
    return False

def can_upgrade_city(g: Game, pid: int, vid: int) -> bool:
    occ = g.occupied_v.get(vid)
    return bool(occ and occ[0]==pid and occ[1]==1)

def distribute_for_roll(g: Game, roll: int, log_cb):
    for vid,(pid,level) in g.occupied_v.items():
        for ti in g.vertex_adj_hexes.get(vid, []):
            t = g.tiles[ti]
            if t.number != roll:
                continue
            res = TERRAIN_TO_RES[t.terrain]
            if not res:
                continue
            amount = 2 if level==2 else 1
            # bank limit
            give = min(amount, g.bank[res])
            if give <= 0:
                continue
            g.bank[res] -= give
            g.players[pid].res[res] += give
    log_cb(f"[ROLL] distributed resources for {roll} (bank limits applied).")

COST = {
    "road": {"wood":1, "brick":1},
    "settlement": {"wood":1, "brick":1, "sheep":1, "wheat":1},
    "city": {"wheat":2, "ore":3},
    "dev": {"sheep":1, "wheat":1, "ore":1},
}
def can_pay(p: Player, cost: Dict[str,int]) -> bool:
    return all(p.res[k] >= v for k,v in cost.items())
def pay_to_bank(g: Game, pid: int, cost: Dict[str,int]):
    p = g.players[pid]
    for k,v in cost.items():
        p.res[k] -= v
        g.bank[k] += v

# -------------------- Graphics Items --------------------
class ClickableEllipse(QtWidgets.QGraphicsEllipseItem):
    def __init__(self, rect: QtCore.QRectF, cb):
        super().__init__(rect)
        self._cb = cb
        self.setAcceptHoverEvents(True)
        self.setAcceptedMouseButtons(QtCore.Qt.LeftButton)
        self._base_pen = QtGui.QPen(QtGui.QColor("#22d3ee"), 2)
        self._base_pen.setCapStyle(QtCore.Qt.RoundCap)
        self._hover_pen = QtGui.QPen(QtGui.QColor("#67e8f9"), 3)
        self._hover_pen.setCapStyle(QtCore.Qt.RoundCap)

    def hoverEnterEvent(self, e):
        self.setPen(self._hover_pen)
        super().hoverEnterEvent(e)

    def hoverLeaveEvent(self, e):
        self.setPen(self._base_pen)
        super().hoverLeaveEvent(e)

    def mousePressEvent(self, e):
        if self._cb:
            self._cb()
        super().mousePressEvent(e)

class ClickableLine(QtWidgets.QGraphicsPathItem):
    def __init__(self, path: QtGui.QPainterPath, cb):
        super().__init__(path)
        self._cb = cb
        self.setAcceptHoverEvents(True)
        self.setAcceptedMouseButtons(QtCore.Qt.LeftButton)
        self._base = QtGui.QPen(QtGui.QColor("#22d3ee"), 7)
        self._base.setCapStyle(QtCore.Qt.RoundCap)
        self._hover = QtGui.QPen(QtGui.QColor("#67e8f9"), 9)
        self._hover.setCapStyle(QtCore.Qt.RoundCap)
        self.setPen(self._base)

    def hoverEnterEvent(self, e):
        self.setPen(self._hover)
        super().hoverEnterEvent(e)

    def hoverLeaveEvent(self, e):
        self.setPen(self._base)
        super().hoverLeaveEvent(e)

    def mousePressEvent(self, e):
        if self._cb:
            self._cb()
        super().mousePressEvent(e)

# -------------------- Main UI --------------------
BG = "#0b2a3a"
PANEL = "#0b2230"
ACCENT = "#22c55e"
TEXT = "#e5e7eb"

class BoardView(QtWidgets.QGraphicsView):
    def __init__(self, scene):
        super().__init__(scene)
        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.TextAntialiasing)
        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self._zoom = 0
        self.setDragMode(QtWidgets.QGraphicsView.NoDrag)
        self._panning = False
        self._pan_start = QtCore.QPoint()

    def wheelEvent(self, e: QtGui.QWheelEvent):
        delta = e.angleDelta().y()
        if delta == 0:
            return
        factor = 1.15 if delta > 0 else 0.87
        self.scale(factor, factor)

    def mousePressEvent(self, e: QtGui.QMouseEvent):
        if e.button() == QtCore.Qt.MiddleButton:
            self._panning = True
            self._pan_start = e.pos()
            self.setCursor(QtCore.Qt.ClosedHandCursor)
            e.accept()
            return
        super().mousePressEvent(e)

    def mouseMoveEvent(self, e: QtGui.QMouseEvent):
        if self._panning:
            delta = e.pos() - self._pan_start
            self._pan_start = e.pos()
            self.translate(delta.x()*-1, delta.y()*-1)
            e.accept()
            return
        super().mouseMoveEvent(e)

    def mouseReleaseEvent(self, e: QtGui.QMouseEvent):
        if e.button() == QtCore.Qt.MiddleButton and self._panning:
            self._panning = False
            self.setCursor(QtCore.Qt.ArrowCursor)
            e.accept()
            return
        super().mouseReleaseEvent(e)

class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("CATAN Р В Р’В Р вЂ™Р’В Р В РІР‚в„ўР вЂ™Р’В Р В Р’В Р вЂ™Р’В Р В Р вЂ Р В РІР‚С™Р вЂ™Р’В Р В Р’В Р вЂ™Р’В Р В РІР‚в„ўР вЂ™Р’В Р В Р’В Р В РІР‚В Р В Р’В Р Р†Р вЂљРЎв„ўР В Р Р‹Р Р†РІР‚С›РЎС›Р В Р’В Р вЂ™Р’В Р В Р’В Р Р†Р вЂљР’В Р В Р’В Р вЂ™Р’В Р В Р вЂ Р В РІР‚С™Р РЋРІвЂћСћР В Р’В Р В Р вЂ№Р В Р Р‹Р РЋРІвЂћСћ Desktop (UI v6: correct geometry & spots)")
        self.resize(1400, 820)

        self.game = build_board(seed=random.randint(1, 999999), size=62.0)

        self.selected_action = None  # "settlement"/"road"/"city"/"dev"
        self.overlay_nodes: Dict[int, QtWidgets.QGraphicsItem] = {}
        self.overlay_edges: Dict[Tuple[int,int], QtWidgets.QGraphicsItem] = {}

        root = QtWidgets.QWidget()
        root.setStyleSheet(f"background:{BG}; color:{TEXT};")
        self.setCentralWidget(root)

        # layout: map big + right panel
        h = QtWidgets.QHBoxLayout(root)
        h.setContentsMargins(18,18,18,18)
        h.setSpacing(14)

        # scene
        self.scene = QtWidgets.QGraphicsScene()
        self.scene.setBackgroundBrush(QtGui.QColor(BG))
        self.view = BoardView(self.scene)

        map_card = QtWidgets.QFrame()
        map_card.setStyleSheet(f"background:{PANEL}; border-radius:18px;")
        map_layout = QtWidgets.QVBoxLayout(map_card)
        map_layout.setContentsMargins(12,12,12,12)
        map_layout.addWidget(self.view, 1)

        # right panel
        right = QtWidgets.QFrame()
        right.setStyleSheet(f"background:{PANEL}; border-radius:18px;")
        right_layout = QtWidgets.QVBoxLayout(right)
        right_layout.setContentsMargins(12,12,12,12)
        right_layout.setSpacing(10)

        self.top_status = QtWidgets.QLabel("")
        self.top_status.setStyleSheet("font-size:13px; opacity:0.9;")
        right_layout.addWidget(self.top_status)

        self.tabs = QtWidgets.QTabWidget()
        self.tabs.setStyleSheet("""
            QTabWidget::pane { border:0; }
            QTabBar::tab { padding:8px 12px; background:#06202d; border-radius:10px; margin-right:6px; }
            QTabBar::tab:selected { background:#0a3145; }
        """)
        self.log = QtWidgets.QPlainTextEdit()
        self.log.setReadOnly(True)
        self.log.setStyleSheet("background:#061a25; border-radius:12px; padding:10px;")
        self.chat = QtWidgets.QPlainTextEdit()
        self.chat.setReadOnly(True)
        self.chat.setStyleSheet("background:#061a25; border-radius:12px; padding:10px;")
        self.tabs.addTab(self.log, "Log")
        self.tabs.addTab(self.chat, "Chat")
        right_layout.addWidget(self.tabs, 1)

        self.chat_in = QtWidgets.QLineEdit()
        self.chat_in.setPlaceholderText("Say somethingР В Р’В Р вЂ™Р’В Р В РІР‚в„ўР вЂ™Р’В Р В Р’В Р вЂ™Р’В Р В Р вЂ Р В РІР‚С™Р вЂ™Р’В Р В Р’В Р вЂ™Р’В Р В РІР‚в„ўР вЂ™Р’В Р В Р’В Р В РІР‚В Р В Р’В Р Р†Р вЂљРЎв„ўР В Р Р‹Р Р†РІР‚С›РЎС›Р В Р’В Р вЂ™Р’В Р В Р вЂ Р В РІР‚С™Р Р†РІР‚С›РЎС›Р В Р’В Р Р†Р вЂљРІвЂћСћР В РІР‚в„ўР вЂ™Р’В¦")
        self.chat_in.setStyleSheet("background:#061a25; border-radius:12px; padding:10px;")
        self.chat_btn = QtWidgets.QPushButton("Send")
        self.chat_btn.setStyleSheet(f"background:{ACCENT}; color:#08131a; padding:10px 14px; border-radius:12px; font-weight:700;")
        self.chat_btn.clicked.connect(self.on_send_chat)
        row = QtWidgets.QHBoxLayout()
        row.addWidget(self.chat_in, 1)
        row.addWidget(self.chat_btn)
        right_layout.addLayout(row)

        # top bar (dice + end turn) inside titlebar area using toolbar-like widget
        top = QtWidgets.QFrame()
        top.setStyleSheet(f"background:{PANEL}; border-radius:18px;")
        top_l = QtWidgets.QHBoxLayout(top)
        top_l.setContentsMargins(14,10,14,10)

        self.lbl_title = QtWidgets.QLabel("CATAN")
        self.lbl_title.setStyleSheet("font-size:18px; font-weight:800;")
        self.lbl_hint = QtWidgets.QLabel("Setup: place settlement. Spots show only when action selected.")
        self.lbl_hint.setStyleSheet("font-size:12px; opacity:0.9;")
        top_l.addWidget(self.lbl_title)
        top_l.addSpacing(14)
        top_l.addWidget(self.lbl_hint, 1)

        self.d1 = QtWidgets.QToolButton()
        self.d2 = QtWidgets.QToolButton()
        self.d1.setIcon(QtGui.QIcon(dice_face(1)))
        self.d2.setIcon(QtGui.QIcon(dice_face(1)))
        for b in (self.d1, self.d2):
            b.setIconSize(QtCore.QSize(44,44))
            b.setFixedSize(54,54)
            b.setStyleSheet("background:#0a3145; border-radius:14px;")
        self.d1.clicked.connect(self.on_roll_click)
        self.d2.clicked.connect(self.on_roll_click)

        self.btn_end = QtWidgets.QPushButton("End turn")
        self.btn_end.setStyleSheet("background:#113a2c; padding:10px 14px; border-radius:12px; font-weight:800;")
        self.btn_end.clicked.connect(self.on_end_turn)

        top_l.addWidget(self.d1)
        top_l.addWidget(self.d2)
        top_l.addSpacing(8)
        top_l.addWidget(self.btn_end)

        # bottom action bar (Colonist-like cards)
        bottom = QtWidgets.QFrame()
        bottom.setStyleSheet(f"background:{PANEL}; border-radius:18px;")
        bottom_l = QtWidgets.QHBoxLayout(bottom)
        bottom_l.setContentsMargins(12,10,12,10)
        bottom_l.setSpacing(10)

        def action_btn(text, key):
            b = QtWidgets.QPushButton(text)
            b.setCheckable(True)
            b.setStyleSheet("""
                QPushButton { background:#06202d; border-radius:14px; padding:12px 16px; font-weight:800; }
                QPushButton:checked { background:#0a3145; border:2px solid #22d3ee; }
            """)
            b.clicked.connect(lambda: self.select_action(key))
            return b

        self.btn_sett = action_btn("Settlement", "settlement")
        self.btn_road = action_btn("Road", "road")
        self.btn_city = action_btn("City", "city")
        self.btn_dev  = action_btn("Dev", "dev")

        bottom_l.addWidget(self.btn_sett)
        bottom_l.addWidget(self.btn_road)
        bottom_l.addWidget(self.btn_city)
        bottom_l.addWidget(self.btn_dev)
        bottom_l.addStretch(1)

        # resource HUD (only player hand here; bank will be in Log later)
        self.res_widgets: Dict[str, QtWidgets.QLabel] = {}
        for rname in RESOURCES:
            box = QtWidgets.QFrame()
            box.setStyleSheet("background:#061a25; border-radius:14px;")
            bl = QtWidgets.QHBoxLayout(box)
            bl.setContentsMargins(10,8,10,8)
            ico = QtWidgets.QLabel()
            ico.setPixmap(make_resource_icon(rname, 40))
            val = QtWidgets.QLabel("0")
            val.setStyleSheet("font-size:16px; font-weight:900;")
            bl.addWidget(ico)
            bl.addWidget(val)
            self.res_widgets[rname] = val
            bottom_l.addWidget(box)

        # main container: left area (top + map + bottom), right panel fixed
        left = QtWidgets.QVBoxLayout()
        left.setSpacing(12)
        left.addWidget(top, 0)
        left.addWidget(map_card, 1)
        left.addWidget(bottom, 0)

        h.addLayout(left, 1)
        h.addWidget(right, 0)

        self._draw_static_board()
        self._log(f"[SYS] New game seed={self.game.seed}. Setup: place settlement then road (x2).")
        self.select_action("settlement")
        QtCore.QTimer.singleShot(30, self._fit_map)
        self._sync_ui()

    # ---------- Drawing ----------
    def _fit_map(self):
        rect = self.scene.itemsBoundingRect().adjusted(-80,-80,80,80)
        self.view.fitInView(rect, QtCore.Qt.KeepAspectRatio)

    def resizeEvent(self, e):
        super().resizeEvent(e)
        QtCore.QTimer.singleShot(0, self._fit_map)

    def _draw_static_board(self):
        self.scene.clear()
        # draw hexes + tokens
        for ti, t in enumerate(self.game.tiles):
            poly = QtGui.QPolygonF(hex_corners(t.center, self.game.size))
            # shadow (pseudo-3D)
            shadow = QtWidgets.QGraphicsPolygonItem(poly.translated(6,6))
            shadow.setBrush(QtGui.QColor("#03131c"))
            shadow.setPen(QtGui.QPen(QtCore.Qt.NoPen))
            shadow.setZValue(0)
            self.scene.addItem(shadow)

            item = QtWidgets.QGraphicsPolygonItem(poly)
            item.setBrush(QtGui.QColor(TERRAIN_COLOR[t.terrain]))
            pen = QtGui.QPen(QtGui.QColor("#062231"), 3)
            pen.setJoinStyle(QtCore.Qt.RoundJoin)
            item.setPen(pen)
            item.setZValue(1)
            self.scene.addItem(item)

            # number token with pips
            if t.number is not None:
                token_r = self.game.size * 0.34
                circ = QtWidgets.QGraphicsEllipseItem(
                    t.center.x()-token_r, t.center.y()-token_r, token_r*2, token_r*2
                )
                circ.setBrush(QtGui.QColor("#f8fafc"))
                circ.setPen(QtGui.QPen(QtGui.QColor("#0b1220"), 2))
                circ.setZValue(3)
                self.scene.addItem(circ)

                txt = QtWidgets.QGraphicsTextItem(str(t.number))
                color = "#ef4444" if t.number in (6,8) else "#0b1220"
                txt.setDefaultTextColor(QtGui.QColor(color))
                f = QtGui.QFont("Segoe UI", 16, QtGui.QFont.Bold)
                txt.setFont(f)
                b = txt.boundingRect()
                txt.setPos(t.center.x()-b.width()/2, t.center.y()-b.height()/2 - 3)
                txt.setZValue(4)
                self.scene.addItem(txt)

                pips = PIPS.get(t.number, 0)
                if pips:
                    pip_y = t.center.y() + token_r*0.40
                    start = t.center.x() - (pips-1)*6
                    for i in range(pips):
                        pip = QtWidgets.QGraphicsEllipseItem(start + i*12 - 3, pip_y-3, 6, 6)
                        pip.setBrush(QtGui.QColor(color))
                        pip.setPen(QtGui.QPen(QtCore.Qt.NoPen))
                        pip.setZValue(4)
                        self.scene.addItem(pip)

        # ports (badges on coast edges)
        self._draw_ports()

        # built pieces will be redrawn on refresh
        self._refresh_all_dynamic()

    def _draw_ports(self):
        center = QtCore.QPointF(0,0)
        for edge, ptype in self.game.ports:
            a,b = edge
            pa = self.game.vertices[a]
            pb = self.game.vertices[b]
            mid = (pa + pb) * 0.5
            # outward offset (choose normal pointing away from center)
            vx, vy = (pb.x()-pa.x()), (pb.y()-pa.y())
            nx, ny = (-vy, vx)
            ln = math.hypot(nx, ny) or 1.0
            nx, ny = nx/ln, ny/ln
            cand1 = QtCore.QPointF(mid.x()+nx*30, mid.y()+ny*30)
            cand2 = QtCore.QPointF(mid.x()-nx*30, mid.y()-ny*30)
            out = cand1 if (cand1-center).manhattanLength() > (cand2-center).manhattanLength() else cand2

            # rounded rect via path (PySide6 has no QGraphicsRoundedRectItem)
            rect = QtCore.QRectF(out.x()-22, out.y()-12, 44, 24)
            path = QtGui.QPainterPath()
            path.addRoundedRect(rect, 10, 10)
            box = QtWidgets.QGraphicsPathItem(path)
            box.setBrush(QtGui.QColor("#061a25"))
            box.setPen(QtGui.QPen(QtGui.QColor("#0a3145"), 2))
            box.setZValue(6)
            self.scene.addItem(box)

            label = ptype.replace("2:1:", "2:1 ")
            txt = QtWidgets.QGraphicsTextItem(label)
            txt.setDefaultTextColor(QtGui.QColor("#e5e7eb"))
            txt.setFont(QtGui.QFont("Segoe UI", 9, QtGui.QFont.Bold))
            br = txt.boundingRect()
            txt.setPos(rect.center().x()-br.width()/2, rect.center().y()-br.height()/2-1)
            txt.setZValue(7)
            self.scene.addItem(txt)

    def _refresh_all_dynamic(self):
        # clear overlays and pieces (simple approach: remove only overlay dict items)
        for it in list(self.overlay_nodes.values()):
            self.scene.removeItem(it)
        for it in list(self.overlay_edges.values()):
            self.scene.removeItem(it)
        self.overlay_nodes.clear()
        self.overlay_edges.clear()

        # draw roads + settlements/cities
        # roads
        for (a,b), pid in self.game.occupied_e.items():
            pa = self.game.vertices[a]
            pb = self.game.vertices[b]
            path = QtGui.QPainterPath(pa)
            path.lineTo(pb)
            it = QtWidgets.QGraphicsPathItem(path)
            pen = QtGui.QPen(self.game.players[pid].color, 10)
            pen.setCapStyle(QtCore.Qt.RoundCap)
            it.setPen(pen)
            it.setZValue(10)
            self.scene.addItem(it)

        # settlements/cities
        for vid,(pid,level) in self.game.occupied_v.items():
            p = self.game.vertices[vid]
            if level == 1:
                self._draw_house(p, self.game.players[pid].color, z=12)
            else:
                self._draw_city(p, self.game.players[pid].color, z=12)

        # show ONLY legal placement spots for current action
        self._show_legal_spots()

    def _draw_house(self, p: QtCore.QPointF, col: QtGui.QColor, z: float):
        # simple "3D-ish" house (original vector)
        w, h = 18, 14
        base = QtGui.QPolygonF([
            QtCore.QPointF(p.x()-w/2, p.y()+h/2),
            QtCore.QPointF(p.x()+w/2, p.y()+h/2),
            QtCore.QPointF(p.x()+w/2, p.y()-h/6),
            QtCore.QPointF(p.x()-w/2, p.y()-h/6),
        ])
        roof = QtGui.QPolygonF([
            QtCore.QPointF(p.x()-w/2-2, p.y()-h/6),
            QtCore.QPointF(p.x(), p.y()-h/2-6),
            QtCore.QPointF(p.x()+w/2+2, p.y()-h/6),
        ])

        sh = QtWidgets.QGraphicsPolygonItem(base.translated(2,2))
        sh.setBrush(QtGui.QColor("#021018"))
        sh.setPen(QtGui.QPen(QtCore.Qt.NoPen))
        sh.setZValue(z-0.2)
        self.scene.addItem(sh)

        b = QtWidgets.QGraphicsPolygonItem(base)
        b.setBrush(col)
        b.setPen(QtGui.QPen(QtGui.QColor("#0b1220"), 2))
        b.setZValue(z)
        self.scene.addItem(b)

        r = QtWidgets.QGraphicsPolygonItem(roof)
        r.setBrush(col.darker(120))
        r.setPen(QtGui.QPen(QtGui.QColor("#0b1220"), 2))
        r.setZValue(z+0.1)
        self.scene.addItem(r)

    def _draw_city(self, p: QtCore.QPointF, col: QtGui.QColor, z: float):
        # bigger block
        w, h = 22, 18
        poly = QtGui.QPolygonF([
            QtCore.QPointF(p.x()-w/2, p.y()+h/2),
            QtCore.QPointF(p.x()+w/2, p.y()+h/2),
            QtCore.QPointF(p.x()+w/2, p.y()-h/2),
            QtCore.QPointF(p.x()-w/2, p.y()-h/2),
        ])
        sh = QtWidgets.QGraphicsPolygonItem(poly.translated(2,2))
        sh.setBrush(QtGui.QColor("#021018"))
        sh.setPen(QtGui.QPen(QtCore.Qt.NoPen))
        sh.setZValue(z-0.2)
        self.scene.addItem(sh)

        it = QtWidgets.QGraphicsPolygonItem(poly)
        it.setBrush(col)
        it.setPen(QtGui.QPen(QtGui.QColor("#0b1220"), 2))
        it.setZValue(z)
        self.scene.addItem(it)

    # ---------- Logic/UI ----------
    def _log(self, s: str):
        self.log.appendPlainText(s)

    def _chat(self, s: str):
        self.chat.appendPlainText(s)

    def _sync_ui(self):
        g = self.game
        p = g.players[g.turn]
        self.top_status.setText(
            f"Players: You(VP {g.players[0].vp}) | Bot(VP {g.players[1].vp})   "
            f"Phase: {g.phase}   Turn: {p.name}   rolled={g.rolled}   lastRoll={g.last_roll}   seed={g.seed}"
        )
        for r in RESOURCES:
            self.res_widgets[r].setText(str(g.players[0].res[r]))

        # hint text
        if g.phase == "setup":
            self.lbl_hint.setText("Setup: place settlement then road. Spots show only for selected action.")
        else:
            self.lbl_hint.setText("Main: click dice to roll. Build by selecting card then clicking highlighted spots.")

    def select_action(self, key: str):
        self.selected_action = key
        # make checkable group
        for b in (self.btn_sett, self.btn_road, self.btn_city, self.btn_dev):
            b.setChecked(False)
        {"settlement":self.btn_sett,"road":self.btn_road,"city":self.btn_city,"dev":self.btn_dev}[key].setChecked(True)
        self._refresh_all_dynamic()
        self._sync_ui()

    def on_send_chat(self):
        txt = self.chat_in.text().strip()
        if not txt:
            return
        self.chat_in.clear()
        self._chat(f"You: {txt}")
        # simple bot reply
        self._chat("Bot: ok.")

    def on_roll_click(self):
        g = self.game
        if g.phase != "main":
            self._log("[!] Roll is available after setup.")
            return
        if g.turn != 0:
            self._log("[!] Wait: bot turn.")
            return
        if g.rolled:
            self._log("[!] Already rolled.")
            return
        a = random.randint(1,6)
        b = random.randint(1,6)
        g.last_roll = a+b
        g.rolled = True
        self.d1.setIcon(QtGui.QIcon(dice_face(a)))
        self.d2.setIcon(QtGui.QIcon(dice_face(b)))
        self._log(f"You rolled {g.last_roll}.")
        distribute_for_roll(g, g.last_roll, self._log)
        self._refresh_all_dynamic()
        self._sync_ui()

    def on_end_turn(self):
        g = self.game
        if g.phase == "setup":
            self._log("[!] Finish setup by placing required piece(s).")
            return
        if g.turn == 0 and not g.rolled:
            self._log("[!] Roll first.")
            return
        # end
        g.turn = 1 - g.turn
        g.rolled = False
        g.last_roll = None
        if g.turn == 1:
            self._bot_turn()
        else:
            self._log("Turn: You")
        self._refresh_all_dynamic()
        self._sync_ui()

    def _bot_turn(self):
        g = self.game
        # bot roll
        a = random.randint(1,6)
        b = random.randint(1,6)
        g.last_roll = a+b
        g.rolled = True
        self._log(f"Bot rolled {g.last_roll}.")
        distribute_for_roll(g, g.last_roll, self._log)

        # very simple build: try settlement then road
        # (UI is the focus now, bot is placeholder)
        # end turn back
        g.turn = 0
        g.rolled = False
        g.last_roll = None
        self._log("Turn: You")

    # ---------- Legal spots + placement handlers ----------
    def _show_legal_spots(self):
        g = self.game
        pid = g.turn
        if pid != 0 and g.phase == "main":
            return

        # setup rules: forced sequence settlement->road, no road requirement for settlement
        if g.phase == "setup":
            if g.setup_need == "settlement":
                # show all legal settlement nodes
                for vid in g.vertices.keys():
                    if can_place_settlement(g, g.setup_order[g.setup_idx], vid, require_road=False):
                        self._add_node_spot(vid, forced_pid=g.setup_order[g.setup_idx])
            else:
                # show only roads from anchor
                assert g.setup_anchor_vid is not None
                for e in g.edges:
                    if g.setup_anchor_vid in e and can_place_road(g, g.setup_order[g.setup_idx], e, must_touch_vid=g.setup_anchor_vid):
                        self._add_edge_spot(e, forced_pid=g.setup_order[g.setup_idx])
            return

        # main phase (player only for now)
        if pid != 0:
            return

        if self.selected_action == "settlement":
            # require road connection in main phase
            for vid in g.vertices.keys():
                if can_place_settlement(g, 0, vid, require_road=True):
                    self._add_node_spot(vid, forced_pid=0)
        elif self.selected_action == "road":
            for e in g.edges:
                if can_place_road(g, 0, e):
                    self._add_edge_spot(e, forced_pid=0)
        elif self.selected_action == "city":
            for vid in g.vertices.keys():
                if can_upgrade_city(g, 0, vid):
                    self._add_node_spot(vid, forced_pid=0)
        elif self.selected_action == "dev":
            # dev is click in UI later; keep no board overlays now
            pass

    def _add_node_spot(self, vid: int, forced_pid: int):
        if vid in self.overlay_nodes:
            return
        p = self.game.vertices[vid]
        r = 8
        rect = QtCore.QRectF(p.x()-r, p.y()-r, r*2, r*2)
        def on_click():
            self._on_node_clicked(vid, forced_pid)
        it = ClickableEllipse(rect, on_click)
        it.setBrush(QtGui.QColor("#061a25"))
        it.setPen(QtGui.QPen(QtGui.QColor("#22d3ee"), 2))
        it.setZValue(20)
        self.scene.addItem(it)
        self.overlay_nodes[vid] = it

    def _add_edge_spot(self, e: Tuple[int,int], forced_pid: int):
        if e in self.overlay_edges:
            return
        a,b = e
        pa = self.game.vertices[a]
        pb = self.game.vertices[b]
        path = QtGui.QPainterPath(pa)
        path.lineTo(pb)
        def on_click():
            self._on_edge_clicked(e, forced_pid)
        it = ClickableLine(path, on_click)
        it.setZValue(19)
        self.scene.addItem(it)
        self.overlay_edges[e] = it

    def _on_node_clicked(self, vid: int, pid: int):
        g = self.game
        if g.phase == "setup":
            # settlement step
            if g.setup_need != "settlement":
                return
            if not can_place_settlement(g, pid, vid, require_road=False):
                return
            g.occupied_v[vid] = (pid, 1)
            g.players[pid].vp += 1
            self._log(f"{g.players[pid].name} placed a settlement.")
            g.setup_need = "road"
            g.setup_anchor_vid = vid
            self._refresh_all_dynamic()
            self._sync_ui()
            return

        # main phase:
        if pid != 0:
            return
        if self.selected_action == "settlement":
            if not can_pay(g.players[0], COST["settlement"]):
                self._log("[!] Not enough resources for settlement.")
                return
            if not can_place_settlement(g, 0, vid, require_road=True):
                return
            pay_to_bank(g, 0, COST["settlement"])
            g.occupied_v[vid] = (0, 1)
            g.players[0].vp += 1
            self._log("You built a settlement.")
        elif self.selected_action == "city":
            if not can_pay(g.players[0], COST["city"]):
                self._log("[!] Not enough resources for city.")
                return
            if not can_upgrade_city(g, 0, vid):
                return
            pay_to_bank(g, 0, COST["city"])
            g.occupied_v[vid] = (0, 2)
            g.players[0].vp += 1
            self._log("You upgraded to a city.")
        self._refresh_all_dynamic()
        self._sync_ui()

    def _on_edge_clicked(self, e: Tuple[int,int], pid: int):
        g = self.game
        if g.phase == "setup":
            if g.setup_need != "road":
                return
            if not can_place_road(g, pid, e, must_touch_vid=g.setup_anchor_vid):
                return
            g.occupied_e[e] = pid
            self._log(f"{g.players[pid].name} placed a road.")
            g.setup_need = "settlement"
            g.setup_anchor_vid = None
            g.setup_idx += 1

            # finish setup after 4 placements (2 per player in 2p)
            if g.setup_idx >= len(g.setup_order):
                g.phase = "main"
                self._log("[SYS] Setup finished. Now roll dice to start.")
            self._refresh_all_dynamic()
            self._sync_ui()
            return

        # main phase
        if pid != 0:
            return
        if self.selected_action != "road":
            return
        if not can_pay(g.players[0], COST["road"]):
            self._log("[!] Not enough resources for road.")
            return
        if not can_place_road(g, 0, e):
            return
        pay_to_bank(g, 0, COST["road"])
        g.occupied_e[e] = 0
        self._log("You built a road.")
        self._refresh_all_dynamic()
        self._sync_ui()

def main():
    app = QtWidgets.QApplication(sys.argv)
    w = MainWindow()
    w.show()

    attach_trade_button(w)





    attach_dev_hand_overlay(w)





    apply_ui_tweaks(w)
    attach_dev_dialog(w)
    attach_dev_dialog(w)
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
